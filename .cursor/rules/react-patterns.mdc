---
description: React and TypeScript patterns specific to Storyboard AI components
globs: 
alwaysApply: false
---
---
description: React and TypeScript patterns specific to Storyboard AI components
globs: ["src/components/**/*.tsx", "src/context/**/*.tsx"]
alwaysApply: false
---

# React Component Patterns for Storyboard AI

## Component Architecture

### Large Component Management
- Split components larger than 500 lines into focused sub-components
- Use React.memo for components with expensive calculations
- Implement proper key props for list rendering to avoid reconciliation issues
- Consider lazy loading with React.Suspense for non-critical components

### TypeScript Integration
- Define prop interfaces using TypeScript interfaces (not types)
- Import interfaces from @src/types/index.ts when available
- Use proper generic typing for components accepting children
- Implement discriminated unions for complex prop variations

### Context Usage Patterns
- Follow StoryboardContext pattern for domain-specific state
- Use ThemeContext pattern for UI state management
- Implement context providers at appropriate component hierarchy levels
- Consider context performance implications for frequent updates

## State Management

### Hook Patterns
- Use useState for simple component-local state
- Implement useEffect with proper dependency arrays
- Use useCallback for functions passed to child components
- Apply useMemo for expensive calculations only

### Custom Hook Creation
- Extract complex state logic into custom hooks
- Follow use[Name] naming convention
- Return objects instead of arrays for better destructuring
- Include proper TypeScript return types

## Performance Optimization

### Rendering Optimization
- Implement React.memo for pure functional components
- Use callback refs for dynamic DOM measurements
- Avoid inline object creation in render methods
- Consider component splitting before other optimizations

### Bundle Optimization
- Use dynamic imports for code splitting at route level
- Implement tree shaking by using named imports
- Avoid importing entire utility libraries
- Consider component-level code splitting for large features

## Error Handling

### Error Boundaries
- Use existing ErrorBoundary.tsx for component failure isolation
- Implement error logging with appropriate context
- Provide fallback UI for component failures
- Test error boundary behavior during development

### Async Error Handling
- Handle Promise rejections in useEffect cleanup
- Implement loading and error states for async operations
- Use try-catch blocks for async/await operations
- Provide user feedback for error conditions

These patterns ensure consistency across the 24 React components in the Storyboard AI codebase.

@src/types/index.ts
@src/components/ErrorBoundary.tsx
